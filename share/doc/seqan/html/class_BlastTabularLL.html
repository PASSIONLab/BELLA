<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" class="class_blasttabularll" data-page="BlastTabularLL">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
    <title>BlastTabularLL - SeqAn API Documentation</title>

      

      
      <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

      <link rel="stylesheet" href="lib/bootstrap/css/bootstrap.css" type="text/css" media="screen" charset="utf-8" />
      <script type="text/javascript" charset="utf-8" src="lib/bootstrap/js/bootstrap.js"></script>

      <link rel="stylesheet" href="lib/bootstrap-multiselect/css/bootstrap-multiselect.css" type="text/css" media="screen" charset="utf-8" />
      <script type="text/javascript" charset="utf-8" src="lib/bootstrap-multiselect/js/bootstrap-multiselect.js"></script>

      <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
      <link rel="stylesheet" href="css/common.less.css" type="text/css" media="screen" charset="utf-8" />
      <script type="text/javascript" charset="utf-8" src="js/less-1.4.1.js"></script>
      



    <script type="text/javascript" charset="utf-8">
      hasFrames = window.top.frames.main ? true : false;
      relpath = '/';
      docsPrefix = 'docs/yard';
      listPrefix = 'list/docs/yard';
      searchPrefix = 'search/docs/yard';
      framesUrl = '/docs/yard/frames/file/README.md';
    </script>

    <style type="text/css">
    .highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
    </style>

    <style>
      .link.error
      {
          color: red;
      }
    </style>

      
      
      <script type="text/javascript" charset="utf-8" src="lib/jquery-bbq/jquery.ba-bbq.js"></script>
      <script type="text/javascript" charset="utf-8" src="js/jquery.smooth-scroll.js"></script>
      <script type="text/javascript" charset="utf-8" src="lib/clipboard/clipboard.js"></script>

      <script type="text/javascript" charset="utf-8" src="js/lang_entities.js"></script>
      <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
      <script type="text/javascript" charset="utf-8" src="js/autocomplete.js"></script>
      <script type="text/javascript" charset="utf-8" src="js/rubydoc_custom.js"></script>
      <script type="text/javascript" charset="utf-8" src="js/common.js"></script>
      
  </head>
  <body>
    <a id="top" name="top"></a>

    <div id="content">
      

<h1 data-lang-entity="class" data-pimped="true"><a href="page_LanguageEntities.html#class">Class</a>
<span>BlastTabularLL<div><div>Low-Level support for Blast Tabular file formats</div></div></span>
</h1>


<table class="overview">

  

  

  

  

  
  </tr>

  <tr>
    <th>Defined in</th>
    <td>
      
      &lt;seqan/blast.h&gt;
      
      
    </td>
  </tr>
  
  <tr>
    <th>Signature</th>
    <td>
      <code>typedef Tag&lt;BlastTabularLL_&gt; BlastTabularLL;
</code>
    </td>
  </tr>
</table>


<!-- Template Parameters -->





<!--
 =============================================================================
  Member and Interface Overview
 =============================================================================
-->

<!-- Member Functions Overview -->




<!-- Interface Functions Overview -->



<div data-lang-entity-container="interface_function">
<h2 data-lang-entity="interface_function">Interface Function Overview</h2>

<ul class="summary">
  
  <li class="public">
    
    <span class="summary_signature"><code><a href="#BlastTabularLL%23onMatch" title="#BlastTabularLL#onMatch (interface function)" data-lang-entity="interface_function">bool onMatch(stream, blastTabularLL)</a></code></span>
    <span class="summary_desc"><div>Returns whether the iterator is on the beginning of a match line.</div></span>
    
  </li>
  
  <li class="public">
    
    <span class="summary_signature"><code><a href="#BlastTabularLL%23readMatch" title="#BlastTabularLL#readMatch (interface function)" data-lang-entity="interface_function">void readMatch(stream, blastTabularLL, args ...);</a></code></span>
    <span class="summary_desc"><div>Low-level BlastTabular file reading.</div></span>
    
  </li>
  
  <li class="public">
    
    <span class="summary_signature"><code><a href="#BlastTabularLL%23skipUntilMatch" title="#BlastTabularLL#skipUntilMatch (interface function)" data-lang-entity="interface_function">void skipUntilMatch(stream, blastTabularLL);</a></code></span>
    <span class="summary_desc"><div>Skip arbitrary number of comment lines until the beginning of a match is reached.</div></span>
    
  </li>
  
  <li class="public">
    
    <span class="summary_signature"><code><a href="#BlastTabularLL%23writeMatch" title="#BlastTabularLL#writeMatch (interface function)" data-lang-entity="interface_function">void writeMatch(stream, blastTabularLL, columns...)</a></code></span>
    <span class="summary_desc"><div>Low-level file-writing for blast tabular formats</div></span>
    
  </li>
  
</ul>








</div>

 


<!-- Member Typedefs Overview -->

  


<!-- Interface Metafunctions Overview -->

  


<!-- Member Variable Overview -->

  


<!--
 =============================================================================
  Detailed Description
 =============================================================================
-->


<h2>Detailed Description</h2>
<div class="docstring">
  <div class="discussion">
    <!-- @internal -->
    

    <!-- @deprecated -->
    

    <!-- @warning -->
    

    <!-- @note -->
    

    <!-- @aka -->
    

    <!-- paragraphs -->
    
<div><p>There are three blast format related tags in SeqAn:</p><p><li> <a href="class_BlastReport.html" data-lang-entity="class">BlastReport</a> with the FormattedFile output specialization <a href="specialization_BlastReportFileOut.html" data-lang-entity="specialization">BlastReportFileOut</a></li>
<li> <a href="class_BlastTabular.html" data-lang-entity="class">BlastTabular</a> with the FormattedFile output and input specializations
<a href="specialization_BlastTabularFileOut.html" data-lang-entity="specialization">BlastTabularFileOut</a> and <a href="specialization_BlastTabularFileIn.html" data-lang-entity="specialization">BlastTabularFileIn</a></li>
<li> <a href="class_BlastTabularLL.html" data-lang-entity="class">BlastTabularLL</a> which provides light-weight, but very basic tabular IO </li></p><p>This is the third tag, it offers <b>low-level</b> support for reading and writing NCBI Blast compatible
<b>tabular</b> files, <b>without comment lines</b> -- although files with comment lines can be read if the comment
lines are skipped. These are the formats that are available in legacy Blast
(<tt>blastall</tt> executable) with the parameters <tt>-m 8</tt> and <tt>-m 9</tt> (with comment lines)
and in BLAST+ (<tt>blastx</tt>, <tt>blastn</tt>...) with
the parameters <tt>-outfmt 6</tt> and <tt>-outfmt 7</tt> respectively.</p><p>For most situations <a href="class_BlastTabular.html" data-lang-entity="class">BlastTabular</a> is more adequate. Use this tag's interface only for quick parsing
of matches in a file, e.g counting and filtering purposes. This interface does not offer a FormattedFile
abstraction and no convenience data structures, it does no transformations on the data.</p><p>The reference Blast implementation used for developing the SeqAn support is NCBI Blast+ 2.2.26 and
NCBI Blast 2.2.26 for the legacy support.</p><h3>Input example</h3><p>The following example program extracts the list of matching query-subject-pairs from a blast tabular file and prints
it to std::out:</p><div data-src-path="demos/blast/blast_in_lowlevel.cpp"><div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;seqan/basic.h&gt;</span>
<span class="cp">#ifndef STDLIB_VS</span>
<span class="cp">#include &lt;seqan/blast.h&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">seqan</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">inPath</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">SEQAN_PATH_TO_ROOT</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot;/tests/blast/plus_comments_defaults.m9&quot;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">fin</span><span class="p">(</span><span class="n">toCString</span><span class="p">(</span><span class="n">inPath</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="o">::</span><span class="n">in</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">fit</span> <span class="o">=</span> <span class="n">directionIterator</span><span class="p">(</span><span class="n">fin</span><span class="p">,</span> <span class="n">Input</span><span class="p">());</span>

    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">THsp</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">THsp</span><span class="o">&gt;</span> <span class="n">hsps</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">atEnd</span><span class="p">(</span><span class="n">fit</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// skip any comment lines</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onMatch</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">BlastTabularLL</span><span class="p">()))</span>
        <span class="p">{</span>
            <span class="n">skipUntilMatch</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">BlastTabularLL</span><span class="p">());</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">atEnd</span><span class="p">(</span><span class="n">fit</span><span class="p">))</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// resize output list</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">hsps</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="n">hsps</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

        <span class="c1">// read only the first two fields into our variables</span>
        <span class="n">readMatch</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">BlastTabularLL</span><span class="p">(),</span> <span class="n">back</span><span class="p">(</span><span class="n">hsps</span><span class="p">).</span><span class="n">first</span><span class="p">,</span> <span class="n">back</span><span class="p">(</span><span class="n">hsps</span><span class="p">).</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">hsps</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">hsps</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">hsps</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">hsps</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">THsp</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="nl">hsp</span> <span class="p">:</span> <span class="n">hsps</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;(&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">hsp</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">hsp</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Demo not run, because of a bug in Microsoft Visual Studio 2015.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
<div class="path_label"><span class="label">Demo:</span> <a href="demos/blast/blast_in_lowlevel.cpp" target="_top">demos/blast/blast_in_lowlevel.cpp</a></div></div><p>The output looks like this:</p><pre class="code" data-src-path="demos/blast/blast_in_lowlevel.cpp.stdout_">(SHAA004TF, sp|P03831|INBD_SHIDY)
(SHAA004TF, sp|P0A915|OMPW_ECOLI)
(SHAA004TF, sp|P0A916|OMPW_SHIFL)
(SHAA004TF, sp|P0CF25|INSB1_ECOLI)
(SHAA004TF, sp|P0CF26|INSB2_ECOLI)
(SHAA004TF, sp|P0CF27|INSB3_ECOLI)
(SHAA004TF, sp|P0CF28|INSB5_ECOLI)
(SHAA004TF, sp|P0CF29|INSB6_ECOLI)
(SHAA004TF, sp|P0CF30|INSB8_ECOLI)
(SHAA004TF, sp|P0CF31|INSB_ECOLX)
(SHAA004TF, sp|P17266|OMPW_VIBCH)
(SHAA004TF, sp|P19765|INSB_SHIFL)
(SHAA004TF, sp|P19766|INSB_SHISO)
(SHAA004TF, sp|P57998|INSB4_ECOLI)
(SHAA004TF, sp|P59843|INSB_HAEDU)
(SHAA004TF, sp|Q8Z7E2|OMPW_SALTI)
(SHAA004TF, sp|Q8ZP50|OMPW_SALTY)
(SHAA004TR, sp|Q0HGZ8|META_SHESM)
(SHAA004TR, sp|Q0HTA5|META_SHESR)
</pre></div>

  </div>
</div>


<!-- @see -->


<!--
 =============================================================================
  Member and Interface Details
 =============================================================================
-->

<!-- Member Functions Details -->






<!-- Interface Functions Details -->

<div class="interface_function_details" data-lang-entity-container="interface_function">
  <h2 data-lang-entity="interface_function">Interface Functions Detail</h2>

  
  <div class="method_details first">
    <h3 data-toc="hidden" id="BlastTabularLL#onMatch" class="signature first" data-lang-entity="interface_function">
      <code>bool onMatch(stream, blastTabularLL)</code>
    </h3>
  </div>

  

  

  

  

  <div class="docstring">
    <div class="discussion">
      <div>Returns whether the iterator is on the beginning of a match line.</div>
    </div>
  </div>

  

  
  <h4>Parameters</h4>
  <table class="overview">
    
    <tr>
      <th>
        
            
                <code data-param-type="in" title="IN parameters are only read and not modified">iter</code>
            
        
      </th>
      <td>An input iterator over a stream or any fwd-iterator over a string.</td>
    </tr>
    
    <tr>
      <th>
        
            
                <code data-param-type="in" title="IN parameters are only read and not modified">blastTabularLL</code>
            
        
      </th>
      <td>The <a href="class_BlastTabularLL.html" data-lang-entity="class">BlastTabularLL</a> tag.</td>
    </tr>
    
  </table>
  
  
  
  <h4>Returns</h4>
  <table class="overview">
    
    <tr>
        <th><code>bool</code></th>
        <td>true or false</td>
    </tr>
    
  </table>
  

	<!-- General description -->

  <div class="docstring">
    <div class="discussion">
      
<div></div>

    </div>
  </div>
 

  <!-- Throws Section -->
	
  
  <h4>Thrown Exceptions</h4>
  <table class="overview">
    
    <tr>
        <th><code>IOError</code></th>
        <td>On low-level I/O errors.</td>
    </tr>
    
  </table>
  
  
  <!-- Data Races Section  -->
  
  <h4>Data Races</h4>
  <div class="discussion">
  
    Thread safety unknown!
  
  </div>
	
	
  <!-- Sees section -->
  
  
  
  <div class="method_details">
    <h3 data-toc="hidden" id="BlastTabularLL#readMatch" class="signature" data-lang-entity="interface_function">
      <code>void readMatch(stream, blastTabularLL, args ...);</code>
    </h3>
  </div>

  

  

  

  

  <div class="docstring">
    <div class="discussion">
      <div>Low-level BlastTabular file reading.</div>
    </div>
  </div>

  

  
  <h4>Parameters</h4>
  <table class="overview">
    
    <tr>
      <th>
        
            
                <code data-param-type="in_out" title="IN/OUT parameters are read and also modified by the called function">stream</code>
            
        
      </th>
      <td>An input iterator over a stream or any fwd-iterator over a string.</td>
    </tr>
    
    <tr>
      <th>
        
            
                <code data-param-type="in" title="IN parameters are only read and not modified">blastTabularLL</code>
            
        
      </th>
      <td>The <a href="class_BlastTabularLL.html" data-lang-entity="class">BlastTabularLL</a> tag.</td>
    </tr>
    
    <tr>
      <th>
        
            
                <code data-param-type="out" title="OUT parameters are modified and used as a means to return values">args</code>
            
        
      </th>
      <td>Arbitrary typed variables able to hold the fields.</td>
    </tr>
    
  </table>
  
  
  

	<!-- General description -->

  <div class="docstring">
    <div class="discussion">
      
<div><h4>Remarks</h4><p>Use this signature only if you do not or cannot use <a href="class_BlastMatch.html" data-lang-entity="class">BlastMatch</a>es. You can specify any number of arguments that are expected
to be able to hold the values in the columns read, i.e. if you pass a
double as argument and the value in the column cannot be successfully cast
to double, an exception will be thrown. If you want to be on the safe side,
you can pass CharStrings and evaluate them in another way.</p><p>You may specify less columns than are available in the file, all but the first
n will be discarded.</p><p>No transformations are made on the data, e.g. the positions are still
one-indexed and flipped for reverse strand matches.</p><p>See <a href="class_BlastTabularLL.html" data-lang-entity="class">BlastTabularLL</a> for an example of low-level IO.</p></div>

    </div>
  </div>
 

  <!-- Throws Section -->
	
  
  <h4>Thrown Exceptions</h4>
  <table class="overview">
    
    <tr>
        <th><code>IOError</code></th>
        <td>On low-level I/O errors.</td>
    </tr>
    
    <tr>
        <th><code>ParseError</code></th>
        <td>On high-level file format errors.</td>
    </tr>
    
  </table>
  
  
  <!-- Data Races Section  -->
  
  <h4>Data Races</h4>
  <div class="discussion">
  
    Thread safety unknown!
  
  </div>
	
	
  <!-- Sees section -->
  
  
  
  <div class="method_details">
    <h3 data-toc="hidden" id="BlastTabularLL#skipUntilMatch" class="signature" data-lang-entity="interface_function">
      <code>void skipUntilMatch(stream, blastTabularLL);</code>
    </h3>
  </div>

  

  

  

  

  <div class="docstring">
    <div class="discussion">
      <div>Skip arbitrary number of comment lines until the beginning of a match is reached.</div>
    </div>
  </div>

  

  
  <h4>Parameters</h4>
  <table class="overview">
    
    <tr>
      <th>
        
            
                <code data-param-type="in_out" title="IN/OUT parameters are read and also modified by the called function">stream</code>
            
        
      </th>
      <td>An input iterator over a stream or any fwd-iterator over a string.</td>
    </tr>
    
    <tr>
      <th>
        
            
                <code data-param-type="in" title="IN parameters are only read and not modified">blastTabularLL</code>
            
        
      </th>
      <td>The <a href="class_BlastTabularLL.html" data-lang-entity="class">BlastTabularLL</a> tag.</td>
    </tr>
    
  </table>
  
  
  

	<!-- General description -->

  <div class="docstring">
    <div class="discussion">
      
<div><h4>Remarks</h4><p>This is also part of the low-level IO and not required if you use readRecord.
Call this function whenever you are not <a href="class_BlastTabularLL.html#BlastTabularLL#onMatch" data-lang-entity="interface_function">onMatch</a>, but want to be, e.g. to
<a href="class_BlastTabularLL.html#BlastTabularLL#readMatch" data-lang-entity="interface_function">readMatch</a>.</p><p>Since it is legal for files to end with comment lines, this function does not throw if end-of-file is reached.
You need to check that after calling.</p></div>

    </div>
  </div>
 

  <!-- Throws Section -->
	
  
  <h4>Thrown Exceptions</h4>
  <table class="overview">
    
    <tr>
        <th><code>IOError</code></th>
        <td>On low-level I/O errors.</td>
    </tr>
    
    <tr>
        <th><code>ParseError</code></th>
        <td>On high-level file format errors.</td>
    </tr>
    
  </table>
  
  
  <!-- Data Races Section  -->
  
  <h4>Data Races</h4>
  <div class="discussion">
  
    Thread safety unknown!
  
  </div>
	
	
  <!-- Sees section -->
  
  
  
  <div class="method_details">
    <h3 data-toc="hidden" id="BlastTabularLL#writeMatch" class="signature" data-lang-entity="interface_function">
      <code>void writeMatch(stream, blastTabularLL, columns...)</code>
    </h3>
  </div>

  

  

  

  

  <div class="docstring">
    <div class="discussion">
      <div>Low-level file-writing for blast tabular formats</div>
    </div>
  </div>

  

  
  <h4>Parameters</h4>
  <table class="overview">
    
    <tr>
      <th>
        
            
                <code data-param-type="in_out" title="IN/OUT parameters are read and also modified by the called function">stream</code>
            
        
      </th>
      <td>The file to write to (FILE, fstream, <a href="concept_OutputStreamConcept.html" data-lang-entity="concept">OutputStreamConcept</a> ...).</td>
    </tr>
    
    <tr>
      <th>
        
            
                <code data-param-type="in" title="IN parameters are only read and not modified">blastTabularLL</code>
            
        
      </th>
      <td>The <a href="class_BlastTabularLL.html" data-lang-entity="class">BlastTabularLL</a> tag.</td>
    </tr>
    
    <tr>
      <th>
        
            
                <code data-param-type="in" title="IN parameters are only read and not modified">columns</code>
            
        
      </th>
      <td>... Any number of printable parameters.</td>
    </tr>
    
  </table>
  
  
  

	<!-- General description -->

  <div class="docstring">
    <div class="discussion">
      
<div><h4>Remarks</h4><p>This is a very leight-weight alternative to <a href="specialization_BlastTabularFileOut.html#BlastTabularFileOut#writeRecord" data-lang-entity="interface_function">writeRecord</a>. It doesn't require
<a href="class_BlastMatch.html" data-lang-entity="class">BlastMatch</a>es, <a href="class_BlastRecord.html" data-lang-entity="class">BlastRecord</a>s or the use of <a href="class_FormattedFile.html" data-lang-entity="class">FormattedFile</a>.
It supports an arbitrary amount of and arbitrary typed columns to be printed.</p><p>Use this only if you do not require comment lines and you are prepared to do all transformations on the data
yourself, i.e. this function does none of the match adjustments mentioned in
<a href="specialization_BlastTabularFileOut.html#BlastTabularFileOut#writeRecord" data-lang-entity="interface_function">writeRecord</a>.</p></div>

    </div>
  </div>
 

  <!-- Throws Section -->
	
  
  <h4>Thrown Exceptions</h4>
  <table class="overview">
    
    <tr>
        <th><code>IOError</code></th>
        <td>On low-level I/O errors.</td>
    </tr>
    
  </table>
  
  
  <!-- Data Races Section  -->
  
  <h4>Data Races</h4>
  <div class="discussion">
  
    Thread safety unknown!
  
  </div>
	
	
  <!-- Sees section -->
  
  
  

</div>



<!-- Member Typedefs Details -->




<!-- Interface Metafunctions Details -->




<!-- Member Variable Details -->




<!--
 =============================================================================
  Footer / Debug
 =============================================================================
-->



<div class="modal fade" id="doxSources" tabindex="-1" role="dialog" aria-labelledby="doxSourcesLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
        <h4 class="modal-title" id="doxSourcesLabel">Dox Sources</h4>
      </div>
      <div class="modal-body">
        <pre>/*!
 * @class BlastTabularLL
 * 
 * @headerfile &lt;seqan/blast.h&gt;
 * 
 * @brief Low-Level support for Blast Tabular file formats
 * 
 * @signature typedef Tag&lt;BlastTabularLL_&gt; BlastTabularLL;
 * 
 * There are three blast format related tags in SeqAn:
 * 
 * &lt;li&gt; @link BlastReport @endlink with the FormattedFile output specialization
 * @link BlastReportFileOut @endlink&lt;/li&gt; &lt;li&gt; @link BlastTabular @endlink with
 * the FormattedFile output and input specializations @link BlastTabularFileOut
 * @endlink and @link BlastTabularFileIn @endlink&lt;/li&gt; &lt;li&gt; @link BlastTabularLL
 * @endlink which provides light-weight, but very basic tabular IO &lt;/li&gt;
 * 
 * This is the third tag, it offers &lt;b&gt;low-level&lt;/b&gt; support for reading and
 * writing NCBI Blast compatible &lt;b&gt;tabular&lt;/b&gt; files, &lt;b&gt;without comment
 * lines&lt;/b&gt; -- although files with comment lines can be read if the comment
 * lines are skipped. These are the formats that are available in legacy Blast
 * (&lt;tt&gt;blastall&lt;/tt&gt; executable) with the parameters &lt;tt&gt;-m 8&lt;/tt&gt; and &lt;tt&gt;-m
 * 9&lt;/tt&gt; (with comment lines) and in BLAST+ (&lt;tt&gt;blastx&lt;/tt&gt;,
 * &lt;tt&gt;blastn&lt;/tt&gt;...) with the parameters &lt;tt&gt;-outfmt 6&lt;/tt&gt; and &lt;tt&gt;-outfmt
 * 7&lt;/tt&gt; respectively.
 * 
 * For most situations @link BlastTabular @endlink is more adequate. Use this
 * tag&#39;s interface only for quick parsing of matches in a file, e.g counting and
 * filtering purposes. This interface does not offer a FormattedFile abstraction
 * and no convenience data structures, it does no transformations on the data.
 * 
 * The reference Blast implementation used for developing the SeqAn support is
 * NCBI Blast+ 2.2.26 and NCBI Blast 2.2.26 for the legacy support.
 * 
 * @section Input example
 * 
 * The following example program extracts the list of matching query-subject-
 * pairs from a blast tabular file and prints it to std::out:
 * 
 * @include demos/blast/blast_in_lowlevel.cpp
 * 
 * The output looks like this:
 * 
 * @include demos/blast/blast_in_lowlevel.cpp.stdout_
 * 
 * 
 * 
 * @fn BlastTabularLL#onMatch
 * 
 * @headerfile seqan/blast.h
 * 
 * @brief Returns whether the iterator is on the beginning of a match line.
 * 
 * @signature bool onMatch(stream, blastTabularLL)
 * 
 * @param[in] iter An input iterator over a stream or any fwd-iterator over a
 *                 string.
 * @param[in] blastTabularLL The @link BlastTabularLL @endlink tag.
 * 
 * @return bool true or false
 * 
 * @throw IOError On low-level I/O errors.
 * 
 * @fn BlastTabularLL#skipUntilMatch
 * 
 * @headerfile seqan/blast.h
 * 
 * @brief Skip arbitrary number of comment lines until the beginning of a match
 *        is reached.
 * 
 * @signature void skipUntilMatch(stream, blastTabularLL);
 * 
 * @param[in,out] stream An input iterator over a stream or any fwd-iterator
 *                       over a string.
 * @param[in] blastTabularLL The @link BlastTabularLL @endlink tag.
 * 
 * @throw IOError On low-level I/O errors.
 * @throw ParseError On high-level file format errors.
 * 
 * @section Remarks
 * 
 * This is also part of the low-level IO and not required if you use readRecord.
 * Call this function whenever you are not @link BlastTabularLL#onMatch
 * @endlink, but want to be, e.g. to @link BlastTabularLL#readMatch @endlink.
 * 
 * Since it is legal for files to end with comment lines, this function does not
 * throw if end-of-file is reached. You need to check that after calling.
 * 
 * @fn BlastTabularLL#readMatch
 * 
 * @headerfile seqan/blast.h
 * 
 * @brief Low-level BlastTabular file reading.
 * 
 * @signature void readMatch(stream, blastTabularLL, args ...);
 * 
 * @param[in,out] stream An input iterator over a stream or any fwd-iterator
 *                       over a string.
 * @param[in] blastTabularLL The @link BlastTabularLL @endlink tag.
 * @param[out] args Arbitrary typed variables able to hold the fields.
 * 
 * @throw IOError On low-level I/O errors.
 * @throw ParseError On high-level file format errors.
 * 
 * @section Remarks
 * 
 * Use this signature only if you do not or cannot use @link BlastMatch
 * @endlinkes. You can specify any number of arguments that are expected to be
 * able to hold the values in the columns read, i.e. if you pass a double as
 * argument and the value in the column cannot be successfully cast to double,
 * an exception will be thrown. If you want to be on the safe side, you can pass
 * CharStrings and evaluate them in another way.
 * 
 * You may specify less columns than are available in the file, all but the
 * first n will be discarded.
 * 
 * No transformations are made on the data, e.g. the positions are still one-
 * indexed and flipped for reverse strand matches.
 * 
 * See @link BlastTabularLL @endlink for an example of low-level IO.
 * 
 * @fn BlastTabularLL#writeMatch
 * 
 * @headerfile seqan/blast.h
 * 
 * @brief Low-level file-writing for blast tabular formats
 * 
 * @signature void writeMatch(stream, blastTabularLL, columns...)
 * 
 * @param[in,out] stream The file to write to (FILE, fstream, @link
 *                       OutputStreamConcept @endlink ...).
 * @param[in] blastTabularLL The @link BlastTabularLL @endlink tag.
 * @param[in] columns ... Any number of printable parameters.
 * 
 * @throw IOError On low-level I/O errors.
 * 
 * @section Remarks
 * 
 * This is a very leight-weight alternative to @link
 * BlastTabularFileOut#writeRecord @endlink. It doesn&#39;t require @link BlastMatch
 * @endlinkes, @link BlastRecord @endlinks or the use of @link FormattedFile
 * @endlink. It supports an arbitrary amount of and arbitrary typed columns to
 * be printed.
 * 
 * Use this only if you do not require comment lines and you are prepared to do
 * all transformations on the data yourself, i.e. this function does none of the
 * match adjustments mentioned in @link BlastTabularFileOut#writeRecord
 * @endlink.
 */</pre>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>





    </div>

  </body>
</html>